---
title: linux进程调度算法
tags:
  - linux
categories:
  - kits
abbrlink: cc71bb07
date: 2019-01-18 10:42:59
---


当发生下面几种情况的时候会调用短程调度器，然后就看下次执行那个进程啦

    时钟中断
    I/O中断
    操作系统调用
    信号（如信号量）


    进程调度算法：
        先来先服务（FCFS）
        短作业优先（SPN）
        最短剩余时间（SRT）
        时间片轮转
        最高响应比优先
        公平共享调度


    先来先服务

<!--more-->

就和名字一样，哪个进程先来就先获得处理器时间，，用一个队列暂存等待处理器的进程，优点是实现简单（太简单了吧喂），缺点，遇到那种又臭又长的进程就很不爽了，好比食堂打饭，前面的人不买一直问，后面的人一直排队，那么后面的人就怎么了呢？后面的人就饥饿！同时如果现在有一个马上就要饿死的人急需吃饭，这就很尴尬了（紧急的进程无法处理，优先级高的进程处于饥饿状态），所以有了优先级队列的先来先服务算法，这样也不是很好，因为总有又臭又长的进程，排队是谁都不乐意的吧，而且处理器时间就不公平了。

    短作业优先

因为先来先服务不好，所以有了短作业优先，通过设置执行时间短的进程作业的优先级为高来实现，也很简单粗暴，就是说进程时间越短就越先执行，看着是比较好了，不浪费时间了，但是有没有想过长进程的感受，来了一群短的进程，然后一直来短进程，这是要饿死长进程的节奏，人家长有错么？如果是可抢占的方式（见最短剩余时间版本），就更惨了，只要来了更短的就别想好好执行了。。。

    最短剩余时间

就是刚才说的短作业优先的抢占版本，说过他的缺点了，当前执行的进程还剩10个时间单位，但是一直来了一群只要2个时间单位就跑完的进程，那当前的进程就会被抢占，然后含恨饿死。。

    时间片轮转

既然上面几种算法都有可能出现饥饿进程，那么我就干脆让每个进程都执行那么一会，这样不就比较公平了？每个进程都有机会在处理器上跑，看起来很和谐，但是还是没有解决优先级的问题，优先级不好控制，比如有什么紧急的进程需要立即执行，就不好办了。而且每个进程的具体情况也是不一样的，比如有I/O消耗型进程，和处理器消耗型进程，在同样的事件片里真正占用处理器的时间是不一样的，而我们是真正占用处理器的时间希望能一样的，这样就公平了嘛。这样看来，时间片轮转也是有缺点的。

    最高响应比优先

什么是响应比？看一下这个公式：R=(w+s)/s，其中R是响应比，w是等待处理器的时间，s是期待的服务时间，简单的来说响应比就是，进程从加入等待队列开始一直到执行完毕经历的时间除以进程使用处理器的时间，这个响应比比较高的就证明该进程等待比较久了，它估计会很饿，先让它吃！

    公平共享调度

Linux系统中普通进程使用的调度方法就是公平共享调度的一个实例，被称作完全公平调度算法（CFS），虽然一定不可能公平。。。详情参照我的另一篇博客。。传送门召唤！！：http://www.cnblogs.com/lenomirei/p/5516872.html

    Linux系统中的进程调度方案

Linux在进行进程调度的时候把进程分为两种：1.普通进程；2.实时进程

实时进程的优先级永远比普通进程的优先级高，也就是说实时进程只要来了就可以抢占普通进程，而且还抓住处理器就不撒手，直到所有的实时进程都执行完毕，才会把处理器让出来给普通进程使用

之前也说了，普通进程的调度采用的是完全公平调度（CFS）对应的是SCHED_NORMAL

而实时进程采用的调度方法就比较简单粗暴了，Linux提供了两种实时调度策略：SCHED_FIFO和SCHED_RR。

SCHED_FIFO：简单的先入先出的调度算法，不使用时间片，只可能被更高优先级的FIFO或者SCHED_RR抢占

SCHED_RR：时间片轮转的方式，优先级比SCHED_FIFO还要高，可以抢占SCHED_FIFO

实时进程的调度没有实时优先级这一说法，采用的是静态优先级，一开始定好优先级之后就不会改变了。
